// привет , сможешь мне помочь с регением вот этос сложной задачи по алгоритмам , мне кажется что тут необходимо взять и реализовать умную проверку случаев и какой-то анализ еще

/* 
------------------------------------------------------------------
твое решение валиться на 2 тесте , а решение с : 



// еще раз 
#include <iostream>
using namespace std;

int main() {
    long long N;
    cin >> N;
    if (N % 4 == 0)
        cout << "Black" << endl;
    else
        cout << "White" << endl;
    return 0;
}
валиться на 12 тесте из 99 , поэтому сможешь еще раз разобрать все возможные связи между числами , чтобы разобрать все возможные случаи
--------------------------------------------------------------------
- такс , больше всего прошли версии( 14 тестов)  : 

if (N % 4 == 0 && N != 12) {  // исключаем N=12
    cout << "Black" << endl;
} else {
    cout << "White" << endl;
}

и 
if (N % 4 == 0 && N % 16 != 12) {
    cout << "Black" << endl;
} else {
    cout << "White" << endl;
}
-------------------------------------------------------------------
все кроме 6 теста прошли на 14 тестов из 99 , а 6 тест прошел на 4 теста

-------------------------------------------------------------------
прикинь все варианты которые ты мне написал прошли 14 тестов и на нем повалились , можешь еще больше проанаализоваро возможных варинатов , чтобы решенипе прошло дальше по тестам 
---- 
попробуй использовать динамику 

*/

#include <bits/stdc++.h>
using namespace std;

// Имитационный dp: dp[n] = true, если выигрыш позиции длины n при обязательном взятии.
vector<char> build_dp(int MAXN) {
    vector<char> dp(MAXN+1, 0);
    dp[0] = 0; // нет хода → проигрыш
    dp[1] = 1; // можно пойти вперёд
    for(int n = 2; n <= MAXN; n++) {
        bool win = false;
        // если взятие — обязательное, но имитируем, что можно взять из n→n-2
        if(!dp[n-2]) win = true;
        // иначе, если нет взятия или взятие не ведёт к выигрышу — можно сходить вперёд
        if(!win && !dp[n-1]) win = true;
        dp[n] = win;
    }
    return dp;
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    long long N;
    cin >> N;

    const int MAXS = 100000;
    auto dp = build_dp(MAXS);

    // Найдём период
    int offset = 5000, period = -1;
    for(int P = 1; P < 5000; P++){
        bool ok = true;
        for(int i = offset; i + P <= MAXS; i++){
            if(dp[i] != dp[i+P]) { ok = false; break; }
        }
        if(ok) { period = P; break; }
    }
    assert(period > 0);

    bool res;
    if(N <= MAXS) res = dp[N];
    else {
        long long idx = offset + (N - offset) % period;
        res = dp[idx];
    }

    cout << (res ? "White\n" : "Black\n");
    return 0;
}
