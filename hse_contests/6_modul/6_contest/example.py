import cmath
import math

def FFT(a):
    """
    Рекурсивное вычисление БПФ для входного списка a.
    Длина a должна быть степенью двойки.
    Возвращает список комплексных чисел - результат преобразования.
    """
    n = len(a)
    if n == 1:
        return a
    
    # Разделяем на четные и нечетные индексы
    a0 = [a[i] for i in range(0, n, 2)]  # четные
    a1 = [a[i] for i in range(1, n, 2)]  # нечетные
    
    # Рекурсивные вызовы для половин
    f0 = FFT(a0)
    f1 = FFT(a1)
    
    # Объединяем результаты
    f = [0] * n
    for j in range(n // 2):
        # Поворачивающий множитель (корень из единицы)
        x = cmath.exp(-2j * cmath.pi * j / n)  # знак "-" для прямого БПФ
        # Комбинируем результаты
        f[j] = f0[j] + x * f1[j]
        f[j + n // 2] = f0[j] - x * f1[j]  # используется свойство симметрии
    
    return f

# Пример использования
if __name__ == "__main__":
    # Входные данные (длина должна быть степенью двойки)
    input_signal = [1, 2, 3, 4]
    
    # Вычисляем БПФ
    result = FFT(input_signal)
    
    print("Входной сигнал:", input_signal)
    print("БПФ результат:")
    for val in result:
        print(f"{val:.3f}")